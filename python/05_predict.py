#! python3

# coding: utf-8

# Date: 2021-02-17
# Author: GS
# Title: EV3 Character Recognition Experiment - Predict
# Description: 
#   Collect, clean, analyse, train and predict character represented 
#   by new refectivity data   
# Version 
#   [1.0] 2021-02-17 Initial

import subprocess
from subprocess import call
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import pickle


def get_prediction_data(logfile, rotations=10, interval=40):
    '''Scan character on reflectivity platform'''

    print(f'Place character on the platform')

    # Execute the 'main.py' script on the ev3. Existing logs (prefixed <filename> are deleted first)
    call(["ssh", "ev3", f"cd ./number_predict; rm {logfile}*;           brickrun -r -- pybricks-micropython main.py --interval {interval} --rotations {rotations} --filename {logfile}"])

    # Copy the results log generated by the script back to the local PC
    subprocess.run(["scp", f"ev3:~/number_predict/{logfile}*", "./raw_data"])

    print(f'  - Character has been scanned')

    # Get name of latest prediction file from the list of '<filename>' files in current directory
    prediction_file = subprocess.call(['sh', 'ls ./raw_data | grep -e $filename'])
    prediction_file = prediction_file[-1]

    return prediction_file


def load_prediction_data(filename):
    '''Load the raw prediction data into a DataFrame'''

    # Read the prediction data into a DataFrame
    df_predict = pd.read_csv(f'./raw_data/{filename}', index_col=False)

    # Remove the space that prefixes the 'reflectivity' column name
    df_predict.columns = ['angle', 'reflectivity']

    return df_predict



def create_rotation_dict():
    '''Initialise a dictionary with keys of 0 to 360 at 10 degree intervals, each with value zero'''
    degree_bins = list(range(0,361,10))
    rotation_dict = {}
    for bin in degree_bins:
        rotation_dict[bin] = 0
    return rotation_dict


# A function to place rotation values into buckets of 10 degrees (+ or - 5 degrees either side)
# These will be the feature columns of each sample rotation
def rotation_buckets(degrees):
    '''Calculate which 360 degree bucket (width=10) the rotation belongs'''
    if degrees > 360 and degrees%360 < 5:
        degrees = (degrees - 5)%360
    else:
        degrees = degrees%360
    modulus = degrees%10
    if modulus < 5:
        bucket = degrees - modulus
    else:
        bucket = (degrees - modulus) + 10
    return bucket


def create_clean_dataframe(raw_prediction_dataframe):
    '''Preprocess raw prediction data'''
    
    df_raw_data = raw_prediction_dataframe
    
    # The experiment was 1 run of X x 360 degree rotations
    # Put actual rotation angle into buckets of 10 degrees between 0 and 360 degrees
    # Concatenate each run of X rotations vertically as tuples of (bucket_degrees, reflectivity_percentage)

    results_list = []
    rotation_column = 'angle'
    reflectivity_column = 'reflectivity'
    for index, row in df_raw_data.iterrows():
        prev_bucket_degrees = -1
        actual_degrees = row[rotation_column]
        bucket_degrees = rotation_buckets(actual_degrees)
        relectivity_percentage = row[reflectivity_column]
        #print(actual_degrees, bucket_degrees, relectivity_percentage)
        results_list.append((bucket_degrees, relectivity_percentage))
        
    # Convert the list of result tuples (rotation angle, refelctivity) to a dictionary of dictionaries where
    # the key is the run number and the value is a dictionary of rotation angles (from 0 to 360 degrees at 
    # 10 degree intervals) and their respective reflectivity value

    run = 0
    results = {}
    dict = create_rotation_dict()
    at_360 = False
    for tuple in results_list:
        if tuple[0] < 360 or at_360 == False:
            dict[tuple[0]] = tuple[1]    
            if tuple[0] >= 360:
                results[run] = dict
                run += 1
                dict = create_rotation_dict()

        at_360 = (tuple[0] >= 360) 
        
    # Create a DataFrame from the angle vs reflectivity results
    df_results = pd.DataFrame.from_dict(results)
    
    # Transpose the DataFrame so each rotation sample is a row and each 10 degree angle of rotation 
    # between 0 and 360 degrees is a feature column
    df_results = df_results.transpose()
    
    # Impute and zero values
    # For angles 0 - 10 degrees use the value of 360 degrees
    df_results[0] = np.where(df_results[0] == 0, df_results[360], df_results[0])
    
    # Where a cell value is zero convert to NaN
    df_results[df_results.eq(0)] = np.nan
    
    # Replace NaN values with the column mean
    df_results.fillna(df_results.mean().astype(int), inplace=True)
    df_results = df_results.astype(int)
    
    # Export the number DataFrame to a .csv file
    df_results.to_csv('./clean_data/prediction_dataset.csv', index=False)
    
    return df_results


def plot_all_prediction_data(df_clean_data):
    '''Plot all rows of the clean prediction data'''

    # Plot all X rotations on the same graph of rotation vs reflectivity
    df_clean_data.transpose().plot(legend=False)
    plt.legend()
    plt.title('Angle vs Reflectivity for each rotation')
    plt.xlabel('Angle of rotation (degrees)')
    plt.ylabel('Reflectivity (%)')
    plt.show()


def plot_summary_prediction_data(df_clean_data):
    '''Plot mean and median of rows in the clean prediction data'''

    df_clean_data.mean().astype(int).plot(label = 'mean')
    df_clean_data.median().astype(int).plot(label = 'median')
    plt.legend()
    plt.title('Angle vs Reflectivity for each rotation')
    plt.xlabel('Angle of rotation (degrees)')
    plt.ylabel('Reflectivity (%)')
    plt.show()


def predict_character(df_clean_data):
    '''Predict the character represented by the new data'''

    # Load machine learning (kNN) model
    knn_model = pickle.load(open('./ml_model/number_reflectivity_knn_model', 'rb'))

    # Assign results to the feature variable
    X_pred = df_clean_data

    # Predict the character (target value) represented by each row of feature reflectivity values
    y_pred = knn_model.predict(X_pred)

    return y_pred


if __name__ == "__main__":

    rotations = 3
    filename = 'predict'

    prediction_filename = get_prediction_data(logfile=filename, rotations=rotations)

    df_raw_prediction_data = load_prediction_data(prediction_filename)

    df_clean_prediction_data = create_clean_dataframe(df_raw_prediction_data)

    plot_all_prediction_data(df_clean_prediction_data)

    plot_summary_prediction_data(df_clean_prediction_data)

    prediction_list = predict_character(df_clean_prediction_data)

    print(f"# Test set predictions: {prediction_list}")

